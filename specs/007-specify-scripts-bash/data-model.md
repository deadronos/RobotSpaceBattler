# Data Model: NavMesh Pathfinding System

**Feature**: NavMesh Pathfinding  
**Date**: 2025-12-10  
**Derived From**: [spec.md](./spec.md), [research.md](./research.md)

## Overview

This document defines the canonical data structures for the NavMesh pathfinding system, including navigation mesh representation, path storage, and ECS component schemas.

## Core Entities

### 1. Navigation Mesh (NavMesh)

Represents the walkable space of the arena as a collection of connected polygons.

```typescript
/**
 * Navigation mesh representing walkable space in the arena.
 * Constructed once per arena configuration and shared across all robots.
 */
interface NavigationMesh {
  /**
   * Unique identifier for this navigation mesh instance
   */
  readonly id: string;
  
  /**
   * Array of convex polygons representing walkable regions
   * Each polygon is defined by an array of 2D points (x, z coordinates)
   */
  readonly polygons: ReadonlyArray<ConvexPolygon>;
  
  /**
   * Adjacency graph connecting navigable polygons
   * Maps polygon index to array of adjacent polygon indices
   */
  readonly adjacency: ReadonlyMap<number, number[]>;
  
  /**
   * Clearance radius used for this mesh (in meters)
   * Obstacles are inflated by this amount to prevent collisions
   */
  readonly clearanceRadius: number;
  
  /**
   * Metadata about mesh generation
   */
  readonly metadata: {
    readonly generatedAt: number; // timestamp
    readonly arenaSize: { readonly width: number; readonly depth: number };
    readonly polygonCount: number;
    readonly memorySize: number; // bytes
  };
}

/**
 * Convex polygon representing a walkable region.
 * Polygons must be convex for efficient pathfinding.
 */
interface ConvexPolygon {
  /**
   * Index of this polygon in the navigation mesh
   */
  readonly index: number;
  
  /**
   * Vertices defining the polygon boundary (2D points in arena space)
   * Points are ordered counter-clockwise
   */
  readonly vertices: ReadonlyArray<Point2D>;
  
  /**
   * Centroid of the polygon (used for A* heuristic)
   */
  readonly centroid: Point2D;
  
  /**
   * Area of the polygon in square meters
   */
  readonly area: number;
}

interface Point2D {
  readonly x: number;
  readonly z: number;
}
```

**Validation Rules**:
- All polygons MUST be convex (no interior angle > 180°)
- Vertices MUST be ordered counter-clockwise
- Minimum 3 vertices per polygon
- Adjacent polygons MUST share exactly 2 vertices (edge)
- Total memory usage MUST be < 5MB

**State Transitions**:
- **Created** → Generated from arena geometry at match start
- **Active** → Used for pathfinding queries
- **Disposed** → Cleaned up at match end

---

### 2. Navigation Path

Ordered sequence of waypoints guiding a robot from start to target.

```typescript
/**
 * Navigation path for a single robot.
 * Generated by A* search and optimized by funnel algorithm.
 */
interface NavigationPath {
  /**
   * Unique identifier for this path instance
   */
  readonly id: string;
  
  /**
   * Entity ID of the robot this path belongs to
   */
  readonly robotId: string;
  
  /**
   * Ordered array of waypoints from start to goal
   * First point is robot's current position, last is target
   */
  readonly waypoints: ReadonlyArray<Point3D>;
  
  /**
   * Current waypoint index (0-based)
   * Robot is moving toward waypoints[currentIndex]
   */
  currentIndex: number;
  
  /**
   * Status of this path
   */
  status: PathStatus;
  
  /**
   * Metadata about path generation
   */
  readonly metadata: {
    readonly generatedAt: number; // timestamp
    readonly calculationTime: number; // milliseconds
    readonly pathLength: number; // meters
    readonly waypointCount: number;
  };
  
  /**
   * Optional debug visualization data
   */
  readonly debug?: {
    readonly rawPath: ReadonlyArray<Point3D>; // before smoothing
    readonly polygonPath: readonly number[]; // indices of polygons traversed
  };
}

interface Point3D {
  readonly x: number;
  readonly y: number;
  readonly z: number;
}

enum PathStatus {
  /**
   * Path is valid and robot is following it
   */
  ACTIVE = 'active',
  
  /**
   * Path calculation completed successfully
   */
  COMPLETED = 'completed',
  
  /**
   * Path became invalid (obstacle moved, target changed)
   * Recalculation needed
   */
  INVALIDATED = 'invalidated',
  
  /**
   * No path exists from start to goal
   * Robot should adopt fallback behavior
   */
  NO_PATH = 'no_path',
  
  /**
   * Path calculation in progress (async operation)
   */
  CALCULATING = 'calculating',
  
  /**
   * Path calculation failed due to error
   */
  FAILED = 'failed'
}

interface Point3D {
  readonly x: number;
  readonly y: number;
  readonly z: number;
}
```

**Validation Rules**:
- Minimum 2 waypoints (start and goal)
- All waypoints MUST be within arena bounds
- Distance between consecutive waypoints MUST be > 0.01m
- currentIndex MUST be in range [0, waypoints.length)
- Path length MUST be calculated as sum of segment distances

**State Transitions**:
```
CALCULATING → ACTIVE (success)
CALCULATING → NO_PATH (no valid path)
CALCULATING → FAILED (error)
ACTIVE → COMPLETED (reached goal)
ACTIVE → INVALIDATED (obstacle/target changed)
INVALIDATED → CALCULATING (recalculation triggered)
```

---

### 3. Path Node

Individual waypoint within a navigation path.

```typescript
/**
 * Single waypoint in a navigation path.
 * May represent polygon centroid, portal edge midpoint, or smoothed position.
 */
interface PathNode {
  /**
   * 3D position in arena space
   */
  readonly position: Point3D;
  
  /**
   * Index of the navigation polygon containing this node
   * -1 if node is not within any polygon (edge case)
   */
  readonly polygonIndex: number;
  
  /**
   * Distance from start along the path (in meters)
   * Used for progress tracking
   */
  readonly distanceFromStart: number;
  
  /**
   * Optional heading direction at this waypoint
   * Null for intermediate nodes, set for goal node
   */
  readonly heading?: number; // radians
}
```

**Validation Rules**:
- position MUST be within arena bounds or on polygon boundary
- distanceFromStart MUST be monotonically increasing along path
- heading MUST be in range [0, 2π) if defined

---

### 4. Walkable Region

High-level representation of navigable areas (derived from navigation mesh).

```typescript
/**
 * Named walkable region for semantic pathfinding.
 * Groups polygons into logical areas (e.g., "north corridor", "center arena").
 */
interface WalkableRegion {
  /**
   * Unique name for this region
   */
  readonly name: string;
  
  /**
   * Indices of polygons belonging to this region
   */
  readonly polygonIndices: readonly number[];
  
  /**
   * Approximate bounding box of the region
   */
  readonly bounds: {
    readonly min: Point2D;
    readonly max: Point2D;
  };
  
  /**
   * Total area of the region in square meters
   */
  readonly area: number;
  
  /**
   * Connected regions (for high-level navigation planning)
   */
  readonly connections: readonly string[]; // region names
}
```

**Validation Rules**:
- name MUST be unique within the navigation mesh
- polygonIndices MUST reference valid polygons
- bounds MUST contain all polygon vertices
- area MUST equal sum of contained polygon areas

---

### 5. Obstacle Geometry

Representation of static obstacles used for navigation mesh generation.

```typescript
/**
 * Static obstacle geometry for NavMesh generation.
 * Represents walls, pillars, and central obstacles.
 */
interface ObstacleGeometry {
  /**
   * Unique identifier for this obstacle
   */
  readonly id: string;
  
  /**
   * Type of obstacle
   */
  readonly type: ObstacleType;
  
  /**
   * 2D footprint of the obstacle (projected to Y=0 plane)
   * Polygon vertices in counter-clockwise order
   */
  readonly footprint: ReadonlyArray<Point2D>;
  
  /**
   * Height of the obstacle (for 3D visualization, not used in 2D pathfinding)
   */
  readonly height: number;
  
  /**
   * Whether this obstacle is passable (e.g., low barrier)
   */
  readonly passable: boolean;
}

enum ObstacleType {
  WALL = 'wall',
  PILLAR = 'pillar',
  CENTRAL_OBSTACLE = 'central_obstacle',
  ARENA_BOUNDARY = 'arena_boundary'
}
```

**Validation Rules**:
- footprint MUST form a closed polygon (first and last points connected)
- height MUST be > 0
- passable obstacles are ignored during NavMesh generation
- footprint MUST be inflated by clearanceRadius during mesh generation

---

## ECS Component Schemas

### PathComponent

Attaches navigation path to a robot entity.

```typescript
/**
 * ECS component storing navigation path for a robot.
 */
interface PathComponent {
  /**
   * Current navigation path, or null if no path
   */
  path: NavigationPath | null;
  
  /**
   * Whether path recalculation is needed
   */
  needsRecalculation: boolean;
  
  /**
   * Target position for pathfinding
   */
  targetPosition: Point3D | null;
  
  /**
   * Last path calculation timestamp
   */
  lastCalculatedAt: number;
  
  /**
   * Number of path recalculations this frame
   * Used to prevent infinite recalculation loops
   */
  recalculationCount: number;
}
```

---

### NavMeshResource

Global ECS resource storing the navigation mesh.

```typescript
/**
 * ECS resource providing shared navigation mesh.
 * Single instance per arena.
 */
interface NavMeshResource {
  /**
   * The navigation mesh instance
   */
  readonly mesh: NavigationMesh;
  
  /**
   * NavMesh library instance for pathfinding queries
   */
  readonly meshInstance: NavMeshLibraryInstance; // from 'navmesh' package
  
  /**
   * Performance metrics
   */
  metrics: {
    totalPathsCalculated: number;
    averageCalculationTime: number; // milliseconds
    cacheHitRate: number; // 0-1
  };
  
  /**
   * Optional path cache for frequently-requested routes
   */
  pathCache?: Map<string, NavigationPath>; // key: "startX,startZ,endX,endZ"
}
```

---

## Relationships

```
NavigationMesh
  ├── contains → ConvexPolygon[] (1 mesh : many polygons)
  └── uses → ObstacleGeometry[] (for generation)

NavigationPath
  ├── belongs to → Robot Entity (1 path : 1 robot)
  ├── consists of → PathNode[] (1 path : many nodes)
  └── traverses → ConvexPolygon[] (via polygon indices)

PathComponent
  ├── attached to → Robot Entity (1 component : 1 robot)
  └── stores → NavigationPath (0..1 path)

NavMeshResource
  ├── shared by → All PathfindingSystem queries
  └── contains → NavigationMesh (1 resource : 1 mesh)

WalkableRegion
  ├── groups → ConvexPolygon[] (1 region : many polygons)
  └── connects to → WalkableRegion[] (region adjacency)
```

## Memory Budget Allocation

Based on clarification: Dynamic allocation, total ≤5MB

```
NavigationMesh (static):
- 100x100m arena with ~100 polygons
- Each polygon: ~10 vertices × 16 bytes = 160 bytes
- Total polygons: 100 × 160 = 16KB
- Adjacency graph: 100 × 5 neighbors × 8 bytes = 4KB
- Total mesh data: ~20KB

NavigationPath (per robot, 20 robots):
- 10-20 waypoints per path
- Each waypoint: 32 bytes (Point3D + metadata)
- Per robot: 20 × 32 = 640 bytes
- Total for 20 robots: 20 × 640 = 12.8KB

PathCache (optional):
- Cache up to 1000 paths
- Each cached path: 640 bytes
- Total cache: 1000 × 640 = 640KB

NavMesh Library Runtime:
- Estimated ~500KB for library code and internal structures

Total Estimated Memory:
- Mesh: 20KB
- Active paths: 12.8KB
- Cache: 640KB
- Library: 500KB
- **Total: ~1.17MB** (well under 5MB budget)
```

## Data Flow

1. **Match Start**:
   - Generate ObstacleGeometry from arena configuration
   - Build NavigationMesh from obstacles using navmesh library
   - Store mesh in NavMeshResource (global ECS resource)

2. **Per Frame (PathfindingSystem)**:
   - Query robots with PathComponent where needsRecalculation = true
   - Call navmesh.findPath(start, target)
   - Store result in PathComponent.path
   - Update PathComponent.lastCalculatedAt

3. **Movement (MovementSystem)**:
   - Read PathComponent.path.waypoints[currentIndex]
   - Apply steering to move robot toward waypoint
   - Increment currentIndex when waypoint reached
   - Trigger recalculation if path.status === INVALIDATED

4. **Dynamic Obstacles**:
   - On obstacle spawn/move event → set PathComponent.needsRecalculation = true
   - PathfindingSystem recalculates affected paths next frame

## Notes

- All interfaces use `readonly` for immutability where appropriate
- 2D pathfinding uses (x, z) coordinates; y is always 0 or robot height
- Memory usage tracked via NavigationMesh.metadata.memorySize
- Performance metrics tracked in NavMeshResource.metrics
